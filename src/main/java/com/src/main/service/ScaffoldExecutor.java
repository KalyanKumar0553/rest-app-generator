package com.src.main.service;

import static java.nio.charset.StandardCharsets.UTF_8;

import java.nio.charset.StandardCharsets;
import java.nio.file.Files;
import java.nio.file.Path;
import java.util.List;
import java.util.Map;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.statemachine.ExtendedState;
import org.springframework.stereotype.Component;

import com.src.main.dto.InitializrProjectModel;
import com.src.main.dto.MavenDependency;
import com.src.main.dto.StepResult;
import com.src.main.utils.AppConstants;
import com.src.main.utils.GradleVersionResolver;
import com.src.main.utils.InitializrGradleGenerator;
import com.src.main.utils.InitializrPomGenerator;

@Component
public class ScaffoldExecutor implements StepExecutor {

	private static final Logger log = LoggerFactory.getLogger(ScaffoldExecutor.class);

	private final DependencyResolver dependencyResolver;
	private final InitializrPomGenerator pomGenerator;
	private final InitializrGradleGenerator gradleGenerator;
	private final TemplateEngine tpl;

	private GradleWrapperInstaller gradleWrapperInstaller;

	public ScaffoldExecutor(DependencyResolver dependencyResolver, InitializrPomGenerator pomGenerator,
			InitializrGradleGenerator gradleGenerator, GradleWrapperInstaller gradleWrapperInstaller,
			TemplateEngine tpl) {
		this.dependencyResolver = dependencyResolver;
		this.pomGenerator = pomGenerator;
		this.gradleGenerator = gradleGenerator;
		this.tpl = tpl;
		this.gradleWrapperInstaller = gradleWrapperInstaller;
	}

	@Override
	@SuppressWarnings("unchecked")
	public StepResult execute(ExtendedState data) throws Exception {
		// Backward-compatible reads (falls back to previous keys if new ones missing)
		final String groupId = strOr(data, AppConstants.GROUP_ID, "groupId", "com.src.main");
		final String artifactId = strOr(data, AppConstants.ARTIFACT_ID, "artifact", "demo-app");
		final String version = strOr(data, AppConstants.VERSION, "version", AppConstants.DEFAULT_VERSION);
		final String name = strOr(data, AppConstants.NAME, null, artifactId);
		final String description = strOr(data, AppConstants.DESCRIPTION, null, "Generated by Rest App Generator");

		final String bootVersion = strOr(data, AppConstants.BOOT_VERSION, null, "3.3.5");
		final String jdkVersion = strOr(data, AppConstants.JDK_VERSION, null, "21");
		final String packaging = strOr(data, AppConstants.PACKAGING, null, "jar");
		final String buildTool = strOr(data, AppConstants.BUILD_TOOL, null, "maven");

		final boolean openapi = boolOr(data, AppConstants.EXTRAS_OPENAPI, true);
		final boolean angular = boolOr(data, AppConstants.EXTRAS_ANGULAR_INTEGRATION, false);

		final String packageName = strOr(data, AppConstants.PACKAGE_NAME, null, groupId);
		final Path root = resolveRoot(data);
		final Map<String, Object> yaml = (Map<String, Object>) data.getVariables().get("yaml");
		final List<String> depReq = (List<String>) data.getVariables().getOrDefault(AppConstants.DEPENDENCIES,
				List.of("web", "validation", "actuator", "test"));

		log.info("Scaffolding project: tool={}, groupId={}, artifactId={}, boot={}, jdk={}, pkg={}, deps={}", buildTool,
				groupId, artifactId, bootVersion, jdkVersion, packaging, depReq);

		createMinimalLayout(root, packageName, buildTool);
		if ("gradle".equalsIgnoreCase(buildTool)) {
			var model = new InitializrProjectModel(groupId, artifactId, version, name, description, packaging,
					jdkVersion, bootVersion, openapi, angular);

			var gradleDeps = dependencyResolver.resolveForGradle(depReq, bootVersion, openapi);
			String settings = gradleGenerator.settingsGradleKts(artifactId);
			String build = gradleGenerator.buildGradleKts(model, gradleDeps);

			Files.writeString(root.resolve("settings.gradle.kts"), settings, UTF_8);
			Files.writeString(root.resolve("build.gradle.kts"), build, UTF_8);
			gradleWrapperInstaller.installWrapper(root, GradleVersionResolver.forBoot(model.bootVersion()));
		} else {
			var model = new InitializrProjectModel(groupId, artifactId, version, name, description, packaging,
					jdkVersion, bootVersion, openapi, angular);

			List<MavenDependency> deps = dependencyResolver.resolveForMaven(depReq, bootVersion, openapi);
			String pom = pomGenerator.generatePom(model, deps);
			Files.writeString(root.resolve("pom.xml"), pom, UTF_8);
		}

		String mainClassName = toPascal(artifactId) + "Application";
		writeMainClass(root, packageName, mainClassName);
		writeResources(root, name);
		writeDocsAndGitignore(root, name);
		return StepResult.ok(Map.of("status", "Success", "root", root.toAbsolutePath().toString(), "groupId", groupId,
				"artifactId", artifactId, "package", packageName, "version", version, "buildTool", buildTool));
	}

	private static Path resolveRoot(ExtendedState data) {
		Object r = data.getVariables().getOrDefault(AppConstants.ROOT_DIR, data.getVariables().get("root"));
		if (r == null)
			throw new IllegalArgumentException("Root directory not provided (AppConstants.ROOT_DIR or 'root').");
		return (r instanceof Path) ? (Path) r : Path.of(r.toString());
	}

	private static String strOr(ExtendedState data, String primaryKey, String legacyKey, String dflt) {
		Object v = primaryKey == null ? null : data.getVariables().get(primaryKey);
		if (v == null && legacyKey != null)
			v = data.getVariables().get(legacyKey);
		return v == null ? dflt : v.toString();
	}

	private static boolean boolOr(ExtendedState data, String key, boolean dflt) {
		Object v = data.getVariables().get(key);
		if (v == null)
			return dflt;
		if (v instanceof Boolean)
			return (Boolean) v;
		return Boolean.parseBoolean(v.toString());
	}

	private static void createMinimalLayout(Path root, String packageName, String buildTool) throws Exception {
		Path mainJava = root.resolve("src/main/java/" + packageName.replace('.', '/'));
		Path mainRes = root.resolve("src/main/resources");
		Path testJava = root.resolve("src/test/java/" + packageName.replace('.', '/'));
		Files.createDirectories(mainJava);
		Files.createDirectories(mainRes);
		Files.createDirectories(testJava);
	}

	private void writeMainClass(Path root, String packageName, String mainClassName) throws Exception {
		Path target = root.resolve("src/main/java/" + packageName.replace('.', '/') + "/" + mainClassName + ".java");
		String rendered = tpl.render(AppConstants.TPL_MAIN, Map.of("basePkg", packageName, "mainClass", mainClassName));

		Files.writeString(target, rendered, UTF_8);
	}

	private void writeResources(Path root, String appName) throws Exception {
		Path resDir = root.resolve("src/main/resources");
		Files.createDirectories(resDir);
		String messagesRendered = tpl.render(AppConstants.TPL_MESSAGES, Map.of());
		Files.writeString(resDir.resolve("messages.properties"), messagesRendered, UTF_8);
	}

	private void writeDocsAndGitignore(Path root, String appName) throws Exception {
		// Ensure project root exists
		Files.createDirectories(root);

		// Template rendering helper (assuming tpl is your Mustache or TemplateEngine
		// instance)
		String readmeRendered = tpl.render(AppConstants.TPL_README, Map.of("appName", appName));
		String gitignoreRendered = tpl.render(AppConstants.TPL_GITIGNORE, Map.of());

		// Write README.md
		Path readmePath = root.resolve("README.md");
		Files.writeString(readmePath, readmeRendered, StandardCharsets.UTF_8);

		// Write .gitignore
		Path gitignorePath = root.resolve(".gitignore");
		Files.writeString(gitignorePath, gitignoreRendered, StandardCharsets.UTF_8);
	}

	private static String toPascal(String s) {
		if (s == null || s.isBlank())
			return "Application";
		String[] parts = s.replace('-', ' ').replace('_', ' ').trim().split("\\s+");
		StringBuilder b = new StringBuilder();
		for (String p : parts) {
			if (!p.isEmpty())
				b.append(Character.toUpperCase(p.charAt(0))).append(p.substring(1));
		}
		return b.append("").toString();
	}
}
