package com.src.main.util;

import java.io.StringWriter;
import java.util.List;
import java.util.Objects;

import org.springframework.stereotype.Component;

import com.src.main.dto.InitializrProjectModel;
import com.src.main.dto.MavenDependencyDTO;

import io.spring.initializr.generator.buildsystem.Dependency;
import io.spring.initializr.generator.buildsystem.DependencyScope;
import io.spring.initializr.generator.buildsystem.maven.MavenBuild;
import io.spring.initializr.generator.buildsystem.maven.MavenBuildWriter;
import io.spring.initializr.generator.io.IndentingWriter;
import io.spring.initializr.generator.version.VersionReference;

@Component
public class InitializrPomGenerator {

	private final MavenBuildWriter writer = new MavenBuildWriter();
	private static final String SPRINGDOC_VERSION = "2.6.0";
	private static final String SWAGGER_CORE_VERSION = "2.2.22";

	public String generatePom(InitializrProjectModel model, List<MavenDependencyDTO> deps) {
		Objects.requireNonNull(model, "model must not be null");
		MavenBuild build = new MavenBuild();
		String groupId = req(model.getGroupId(), "groupId");
		String artifact = req(model.getArtifactId(), "artifactId");
		String bootVer = nz(model.getBootVersion(), "3.3.5");
		String appVer = nz(model.getVersion(), "0.0.1-SNAPSHOT");
		String name = nz(model.getName(), artifact);
		String desc = nz(model.getDescription(), "Generated by Rest App Generator");
		String packaging = nz(model.getPackaging(), "jar");
		String jdk = nz(model.getJdkVersion(), "21");
		build.settings().parent("org.springframework.boot", "spring-boot-starter-parent", bootVer);
		build.settings().group(groupId);
		build.settings().artifact(artifact);
		build.settings().version(appVer);
		build.settings().name(name);
		build.settings().description(desc);
		build.settings().packaging(packaging);
		build.properties().version("java", jdk);
		if (deps != null) {
			deps.stream()
					.filter(Objects::nonNull)
					.map(md -> new String[] { trimOrNull(md.groupId()), trimOrNull(md.artifactId()), md.scope() })
					.filter(parts -> parts[0] != null && parts[1] != null)
					.forEach(parts -> {
						String id = parts[0] + ":" + parts[1];
						build.dependencies().add(id,
								Dependency.withCoordinates(parts[0], parts[1]).scope(toScope(parts[2])));
					});
		}
		boolean includeJpa = hasJpaDependency(deps);
		if (model.isIncludeLombok()) {
			build.dependencies().add("lombok", Dependency.withCoordinates("org.projectlombok", "lombok")
					.scope(DependencyScope.ANNOTATION_PROCESSOR).build());
		}
		if (includeJpa) {
			build.dependencies().add("jakarta-persistence-api", Dependency
					.withCoordinates("jakarta.persistence", "jakarta.persistence-api").scope(DependencyScope.COMPILE_ONLY));
		}
		if (model.isIncludeOpenapi()) {
			build.dependencies().add("springdoc-openapi-ui",
					Dependency.withCoordinates("org.springdoc", "springdoc-openapi-starter-webmvc-ui")
							.version(VersionReference.ofValue(SPRINGDOC_VERSION))
							.scope(DependencyScope.COMPILE));
			build.dependencies().add("swagger-models",
					Dependency.withCoordinates("io.swagger.core.v3", "swagger-models")
							.version(VersionReference.ofValue(SWAGGER_CORE_VERSION))
							.scope(DependencyScope.COMPILE));
			build.dependencies().add("swagger-annotations",
					Dependency.withCoordinates("io.swagger.core.v3", "swagger-annotations")
							.version(VersionReference.ofValue(SWAGGER_CORE_VERSION))
							.scope(DependencyScope.COMPILE));
		}

		if ("jar".equalsIgnoreCase(packaging) == false && "war".equalsIgnoreCase(packaging)) {
			build.dependencies().add("org.springframework.boot:spring-boot-starter-tomcat",
					Dependency.withCoordinates("org.springframework.boot", "spring-boot-starter-tomcat")
							.scope(DependencyScope.PROVIDED_RUNTIME));
		}
		build.plugins().add("org.springframework.boot", "spring-boot-maven-plugin", p -> p.version(bootVer));
		StringWriter out = new StringWriter();
		try (IndentingWriter iw = new IndentingWriter(out, s -> "    ")) {
			MavenBuildWriter writer = new MavenBuildWriter();
			writer.writeTo(iw, build);
		} catch (Exception e) {
			throw new IllegalStateException("Failed to render pom.xml", e);
		}
		return out.toString();
	}

	private static String req(String v, String name) {
		if (v == null || v.isBlank())
			throw new IllegalArgumentException(name + " must not be null/blank");
		return v.trim();
	}

	private static String nz(String v, String dflt) {
		return (v == null || v.isBlank()) ? dflt : v.trim();
	}

	private static String trimOrNull(String v) {
		return (v == null || v.isBlank()) ? null : v.trim();
	}

	private static boolean hasJpaDependency(List<MavenDependencyDTO> deps) {
		if (deps == null || deps.isEmpty()) {
			return false;
		}
		return deps.stream().filter(Objects::nonNull)
				.anyMatch(d -> "org.springframework.boot".equalsIgnoreCase(d.groupId())
						&& "spring-boot-starter-data-jpa".equalsIgnoreCase(d.artifactId()));
	}

	private DependencyScope toScope(String raw) {
		if (raw == null || raw.isBlank())
			return DependencyScope.COMPILE;
		switch (raw.trim().toLowerCase()) {
		case "annotation_processor":
		case "annotation-processor":
			return DependencyScope.ANNOTATION_PROCESSOR;
		case "compile_only":
		case "compile-only":
			return DependencyScope.COMPILE_ONLY;
		case "runtime":
		case "runtimeonly":
			return DependencyScope.RUNTIME;
		case "provided":
		case "providedruntime":
		case "provided_runtime":
			return DependencyScope.PROVIDED_RUNTIME;
		case "test":
		case "test_compile":
		case "test-compile":
			return DependencyScope.TEST_COMPILE;
		case "test_runtime":
		case "test-runtime":
			return DependencyScope.TEST_RUNTIME;
		default:
			return DependencyScope.COMPILE;
		}
	}
}
