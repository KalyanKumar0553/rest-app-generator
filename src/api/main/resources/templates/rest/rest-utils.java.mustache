package {{supportPackage}};

import java.lang.reflect.Field;
import java.lang.reflect.Modifier;
import java.math.BigDecimal;
import java.time.Instant;
import java.time.LocalDate;
import java.time.LocalDateTime;
import java.time.OffsetDateTime;
import java.util.ArrayList;
import java.util.List;
import java.util.Map;
import java.util.UUID;

import org.springframework.data.jpa.domain.Specification;
import org.springframework.util.ReflectionUtils;

import jakarta.persistence.criteria.Predicate;

public final class RestUtils {

    private RestUtils() {
    }

    public static <T> Specification<T> buildSpecification(Map<String, String> queryParams, Class<T> entityType) {
        return (root, query, criteriaBuilder) -> {
            List<Predicate> predicates = new ArrayList<>();
            queryParams.forEach((fieldName, rawValue) -> {
                if (rawValue == null || rawValue.isBlank()) {
                    return;
                }
                Class<?> fieldType = resolveFieldType(entityType, fieldName);
                Object converted = convertValue(rawValue, fieldType);
                predicates.add(criteriaBuilder.equal(root.get(fieldName), converted));
            });
            return criteriaBuilder.and(predicates.toArray(new Predicate[0]));
        };
    }

    public static <T> void mergeNonNullFields(T source, T target, String idField) {
        for (Field field : collectFields(source.getClass())) {
            int modifiers = field.getModifiers();
            if (Modifier.isStatic(modifiers) || Modifier.isFinal(modifiers) || field.getName().equals(idField)) {
                continue;
            }
            ReflectionUtils.makeAccessible(field);
            Object value = ReflectionUtils.getField(field, source);
            if (value != null) {
                ReflectionUtils.setField(field, target, value);
            }
        }
    }

    private static Class<?> resolveFieldType(Class<?> entityType, String fieldName) {
        Field field = ReflectionUtils.findField(entityType, fieldName);
        if (field == null) {
            throw new IllegalArgumentException("Unknown query field: " + fieldName);
        }
        return field.getType();
    }

    private static Object convertValue(String value, Class<?> type) {
        if (type == String.class) {
            return value;
        }
        if (type == Integer.class || type == int.class) {
            return Integer.valueOf(value);
        }
        if (type == Long.class || type == long.class) {
            return Long.valueOf(value);
        }
        if (type == Boolean.class || type == boolean.class) {
            return Boolean.valueOf(value);
        }
        if (type == Double.class || type == double.class) {
            return Double.valueOf(value);
        }
        if (type == Float.class || type == float.class) {
            return Float.valueOf(value);
        }
        if (type == BigDecimal.class) {
            return new BigDecimal(value);
        }
        if (type == UUID.class) {
            return UUID.fromString(value);
        }
        if (type == LocalDate.class) {
            return LocalDate.parse(value);
        }
        if (type == LocalDateTime.class) {
            return LocalDateTime.parse(value);
        }
        if (type == OffsetDateTime.class) {
            return OffsetDateTime.parse(value);
        }
        if (type == Instant.class) {
            return Instant.parse(value);
        }
        if (type.isEnum()) {
            @SuppressWarnings({ "rawtypes", "unchecked" })
            Object enumValue = Enum.valueOf((Class<? extends Enum>) type.asSubclass(Enum.class), value);
            return enumValue;
        }
        throw new IllegalArgumentException("Unsupported query field type for field: " + type.getSimpleName());
    }

    private static List<Field> collectFields(Class<?> type) {
        List<Field> fields = new ArrayList<>();
        Class<?> current = type;
        while (current != null && current != Object.class) {
            for (Field field : current.getDeclaredFields()) {
                fields.add(field);
            }
            current = current.getSuperclass();
        }
        return fields;
    }
}
