import { Injectable } from '@angular/core';
import { convertObjectToYaml } from '../utils/yaml.utils';
import {
  trimmed,
  hasNumber,
  toNumberIfPossible,
  toBooleanIfPossible,
  normalizeType,
  toSnakeCase,
  toArtifactId,
  toDatabaseCode,
  resolveDatabaseType,
  normalizeProfileName,
  isValidProfileName,
  isNotNullConstraint
} from '../utils/project-generation.utils';
import { DEFAULT_CONTROLLERS_CONFIG } from '../components/project-generation-dashboard/project-generation-dashboard.defaults';
import { RestEndpointConfig } from '../components/rest-config/rest-config.component';
import { ACTUATOR_ENDPOINT_OPTIONS, DEFAULT_ACTUATOR_ENDPOINTS } from '../components/actuator-config/actuator-config.component';

@Injectable({ providedIn: 'root' })
export class ProjectSpecMapperService {

  buildYaml(project: any): string {
    return convertObjectToYaml(this.mapProjectToGeneratorSpec(project));
  }

  mapProjectToGeneratorSpec(project: any): any {
    const projectGroup = trimmed(project?.settings?.projectGroup) || 'com.example';
    const projectName = trimmed(project?.settings?.projectName) || 'demo-app';
    const databaseCode = toDatabaseCode(project?.database?.database);

    const app = {
      name: projectName,
      groupId: projectGroup,
      artifactId: toArtifactId(projectName),
      description: 'Generated by Rest App Generator',
      version: '0.0.1-SNAPSHOT',
      jdkVersion: trimmed(project?.preferences?.javaVersion) || '17',
      buildTool: trimmed(project?.settings?.buildType) || 'gradle',
      generator: trimmed(project?.settings?.language) || 'java'
    };

    const includeControllersSpec =
      Boolean(project?.preferences?.configureApi)
      && project?.controllers?.enabled !== false
      && this.hasNamedControllersConfig(project?.controllers?.config);
    const restSpecSection = this.buildRestSpecSection(project?.entities, project?.controllers?.config, includeControllersSpec);
    const spec: any = {
      app,
      database: databaseCode,
      dbType: resolveDatabaseType(project?.database?.dbType, databaseCode),
      applFormat: trimmed(project?.preferences?.applFormat) || 'yaml',
      enableOpenapi: Boolean(project?.preferences?.enableOpenAPI),
      enableActuator: Boolean(project?.preferences?.enableActuator),
      enableLombok: Boolean(
        project?.preferences?.enableLombok === undefined
          ? project?.preferences?.optionalLombok
          : project?.preferences?.enableLombok
      ),
      useDockerCompose: Boolean(project?.preferences?.useDockerCompose),
      packages: trimmed(project?.preferences?.packages) || 'technical',
      profiles: this.mapProfiles(project?.preferences?.profiles),
      dependencies: this.extractDependencies(project?.dependencies ?? '', project?.selectedDependencies ?? []),
      basePackage: projectGroup,
      models: this.mapModels(project?.entities, project?.relations, restSpecSection.entityToSpecName),
      dtos: this.mapDtos(project?.dataObjects),
      enums: this.mapEnums(project?.enums)
    };

    const mapperSpecs = this.mapMappers(project?.mappers);
    if (mapperSpecs.length) {
      spec.mappers = mapperSpecs;
    }

    if (databaseCode !== 'NONE') {
      spec.dbGeneration = trimmed(project?.database?.dbGeneration) || 'Hibernate (update)';
      spec.pluralizeTableNames = Boolean(project?.database?.pluralizeTableNames);
    }

    if (Boolean(project?.preferences?.enableActuator)) {
      const actuatorConfigOptions = this.getActuatorConfigurationOptions(project?.preferences?.profiles);
      const actuatorConfigurations = this.sanitizeActuatorConfigurations(
        project?.actuator?.configurations ?? project?.actuator?.endpoints,
        actuatorConfigOptions
      );
      spec.actuator = {
        endpoints: {
          include: this.sanitizeActuatorEndpoints(actuatorConfigurations['default'])
        },
        profiles: Object.entries(actuatorConfigurations)
          .filter(([profile]) => profile !== 'default')
          .reduce((acc, [profile, endpoints]) => {
            acc[profile] = {
              endpoints: {
                include: this.sanitizeActuatorEndpoints(endpoints)
              }
            };
            return acc;
          }, {} as Record<string, unknown>)
      };
    }

    if (
      Boolean(project?.preferences?.configureApi)
      && project?.controllers?.enabled !== false
      && this.hasNamedControllersConfig(project?.controllers?.config)
    ) {
      const controllersConfig = this.mapRestConfig(project?.controllers?.config);
      if (controllersConfig) {
        spec.controllers = controllersConfig;
      }
    }

    if (restSpecSection.specs.length) {
      spec['rest-spec'] = restSpecSection.specs;
    }

    if (!spec.dependencies.length) {
      delete spec.dependencies;
    }
    if (!spec.models.length) {
      delete spec.models;
    }
    if (!spec.dtos.length) {
      delete spec.dtos;
    }
    if (!spec.enums.length) {
      delete spec.enums;
    }

    return spec;
  }

  mapModels(entities: any, relations: any, entityToSpecName: Record<string, string> = {}): any[] {
    const entityList = Array.isArray(entities) ? entities : [];
    const relationList = Array.isArray(relations) ? relations : [];

    return entityList.map((entity) => {
      const fields = Array.isArray(entity?.fields) ? entity.fields : [];
      const idField = fields.find((field: any) => Boolean(field?.primaryKey));
      const nonIdFields = fields.filter((field: any) => !field?.primaryKey);
      const modelRelations = relationList
        .filter((relation: any) => trimmed(relation?.sourceEntity) === trimmed(entity?.name))
        .map((relation: any) => this.mapRelation(relation));

      const model: any = {
        name: trimmed(entity?.name) || 'Entity',
        tableName: toSnakeCase(trimmed(entity?.name) || 'entity'),
        addRestEndpoints: Boolean(entity?.addRestEndpoints),
        addCrudOperations: Boolean(entity?.addCrudOperations),
        classMethods: this.mapClassMethods(entity?.classMethods),
        options: {
          entity: !Boolean(entity?.mappedSuperclass),
          immutable: Boolean(entity?.immutable),
          auditing: Boolean(entity?.auditable),
          softDelete: Boolean(entity?.softDelete),
          naturalIdCache: Boolean(entity?.naturalIdCache)
        },
        id: this.mapId(idField),
        fields: nonIdFields.map((field: any) => this.mapModelField(field))
      };

      const entityName = trimmed(entity?.name);
      const mappedSpecName = entityToSpecName[entityName];
      if (mappedSpecName) {
        model['rest-spec-name'] = mappedSpecName;
      }

      const restConfig = this.mapRestConfig(entity?.restConfig);
      if (restConfig) {
        model.rest = restConfig;
      }

      if (modelRelations.length) {
        model.relations = modelRelations;
      }

      return model;
    });
  }

  buildRestSpecSection(
    entities: any,
    controllersConfig: any,
    includeControllers: boolean
  ): { specs: any[]; entityToSpecName: Record<string, string> } {
    const specs: any[] = [];
    const entityToSpecName: Record<string, string> = {};
    const specIndexByName = new Map<string, number>();
    const entityList = Array.isArray(entities) ? entities : [];

    const addOrUpdateSpec = (name: string, config: any): string => {
      const specName = trimmed(name) || 'RestSpec';
      const existingIndex = specIndexByName.get(specName);
      if (existingIndex === undefined) {
        specIndexByName.set(specName, specs.length);
        specs.push({ name: specName, ...config });
      } else {
        specs[existingIndex] = { name: specName, ...config };
      }
      return specName;
    };

    entityList.forEach((entity: any) => {
      if (!Boolean(entity?.addRestEndpoints)) {
        return;
      }
      const mapped = this.mapRestConfig(entity?.restConfig);
      if (!mapped) {
        return;
      }
      const entityName = trimmed(entity?.name);
      const specName = addOrUpdateSpec(trimmed(mapped.resourceName) || entityName || 'EntityRest', mapped);
      if (entityName) {
        entityToSpecName[entityName] = specName;
      }
    });

    if (includeControllers) {
      const mappedControllers = this.mapRestConfig(controllersConfig);
      if (mappedControllers) {
        addOrUpdateSpec(trimmed(mappedControllers.resourceName) || 'ControllersRest', mappedControllers);
      }
    }

    return { specs, entityToSpecName };
  }

  hasNamedControllersConfig(config: any): boolean {
    return Boolean(trimmed(config?.resourceName));
  }

  mapRestConfig(restConfig: any): any | null {
    if (!restConfig || typeof restConfig !== 'object') {
      return null;
    }
    const operations: string[] = [
      'list', 'get', 'create', 'patch', 'delete',
      'bulkInsert', 'bulkUpdate', 'bulkDelete'
    ];

    const methods: Record<string, any> = {};
    operations.forEach((key) => {
      if (!Boolean(restConfig?.methods?.[key])) {
        return;
      }
      const documentation = this.buildOperationDocumentationConfig(restConfig, key);
      methods[key] = {
        request: this.buildOperationRequestConfig(key, restConfig),
        response: this.buildOperationResponseConfig(restConfig, key),
        ...(documentation ? { documentation } : {})
      };
    });

    return {
      resourceName: trimmed(restConfig.resourceName),
      basePath: trimmed(restConfig.basePath),
      apiVersioning: {
        enabled: Boolean(restConfig?.apiVersioning?.enabled),
        strategy: restConfig?.apiVersioning?.strategy === 'path' ? 'path' : 'header',
        headerName: trimmed(restConfig?.apiVersioning?.headerName),
        defaultVersion: trimmed(restConfig?.apiVersioning?.defaultVersion)
      },
      pathVariableType: ['UUID', 'LONG', 'STRING'].includes(String(restConfig?.pathVariableType))
        ? restConfig.pathVariableType
        : 'UUID',
      deletion: {
        mode: restConfig?.deletion?.mode === 'HARD' ? 'HARD' : 'SOFT',
        restoreEndpoint: Boolean(restConfig?.deletion?.restoreEndpoint),
        includeDeletedParam: Boolean(restConfig?.deletion?.includeDeletedParam)
      },
      hateoas: {
        enabled: Boolean(restConfig?.hateoas?.enabled),
        selfLink: Boolean(restConfig?.hateoas?.selfLink),
        updateLink: Boolean(restConfig?.hateoas?.updateLink),
        deleteLink: Boolean(restConfig?.hateoas?.deleteLink)
      },
      documentation: {
        includeDefaultDocumentation: restConfig?.documentation?.includeDefaultDocumentation !== false
      },
      methods
    };
  }

  mapDtos(dataObjects: any): any[] {
    const items = Array.isArray(dataObjects) ? dataObjects : [];
    return items.map((dataObject: any) => {
      const dto: any = {
        name: trimmed(dataObject?.name) || 'DataObject',
        type: trimmed(dataObject?.dtoType) || 'request',
        classMethods: this.mapClassMethods(dataObject?.classMethods),
        fields: (Array.isArray(dataObject?.fields) ? dataObject.fields : []).map((field: any) => this.mapDtoField(field))
      };

      if (dataObject?.mapperEnabled && Array.isArray(dataObject?.mapperModels) && dataObject.mapperModels.length) {
        dto.mapper = {
          enabled: true,
          models: dataObject.mapperModels.map((name: any) => trimmed(name)).filter(Boolean)
        };
      }

      return dto;
    });
  }

  mapEnums(enums: any): any[] {
    const items = Array.isArray(enums) ? enums : [];
    return items
      .map((enumItem: any) => ({
        name: trimmed(enumItem?.name),
        storage: trimmed(enumItem?.storage) || 'STRING',
        constants: Array.isArray(enumItem?.constants)
          ? enumItem.constants.map((item: any) => trimmed(item)).filter(Boolean)
          : []
      }))
      .filter((enumItem: any) => enumItem.name && enumItem.constants.length > 0);
  }

  mapMappers(mappers: any): any[] {
    const items = Array.isArray(mappers) ? mappers : [];
    return items
      .map((mapper: any) => ({
        name: trimmed(mapper?.name),
        fromModel: trimmed(mapper?.fromModel),
        toModel: trimmed(mapper?.toModel),
        mappings: Array.isArray(mapper?.mappings)
          ? mapper.mappings
            .map((item: any) => ({
              sourceField: trimmed(item?.sourceField),
              targetField: trimmed(item?.targetField)
            }))
            .filter((item: any) => item.sourceField && item.targetField)
          : []
      }))
      .filter((mapper: any) => mapper.name && mapper.fromModel && mapper.toModel && mapper.mappings.length > 0);
  }

  extractDependencies(dependenciesString: string, selectedDependencies: string[]): string[] {
    const fromString = String(dependenciesString ?? '')
      .split(',')
      .map((item) => item.trim())
      .filter(Boolean);
    const fromSelected = Array.isArray(selectedDependencies)
      ? selectedDependencies.map((item) => String(item).trim()).filter(Boolean)
      : [];
    return Array.from(new Set([...fromSelected, ...fromString]));
  }

  mapProfiles(profiles: unknown): string[] {
    if (!Array.isArray(profiles)) {
      return [];
    }
    const normalized = profiles
      .map(profile => normalizeProfileName(profile))
      .filter((profile): profile is string => Boolean(profile))
      .filter(profile => isValidProfileName(profile));
    return Array.from(new Set(normalized));
  }

  getActuatorConfigurationOptions(profileSource: unknown): string[] {
    const normalizedProfiles = this.mapProfiles(profileSource).filter(profile => profile !== 'default');
    return ['default', ...normalizedProfiles];
  }

  sanitizeActuatorEndpoints(rawEndpoints: unknown): string[] {
    const allowed = new Set(ACTUATOR_ENDPOINT_OPTIONS.map((option) => option.value));
    if (!Array.isArray(rawEndpoints)) {
      return [...DEFAULT_ACTUATOR_ENDPOINTS];
    }
    const cleaned = rawEndpoints
      .map((item) => String(item || '').trim().toLowerCase())
      .filter((item) => item && allowed.has(item));
    const unique = Array.from(new Set(cleaned));
    return unique.length ? unique : [...DEFAULT_ACTUATOR_ENDPOINTS];
  }

  sanitizeActuatorConfigurations(
    rawConfigurations: unknown,
    availableConfigurations: string[]
  ): Record<string, string[]> {
    const allowedConfigurations = new Set(availableConfigurations);
    const sanitized: Record<string, string[]> = {
      default: [...DEFAULT_ACTUATOR_ENDPOINTS]
    };

    if (Array.isArray(rawConfigurations)) {
      sanitized['default'] = this.sanitizeActuatorEndpoints(rawConfigurations);
      return sanitized;
    }

    if (!(rawConfigurations instanceof Object)) {
      return sanitized;
    }

    Object.entries(rawConfigurations as Record<string, unknown>).forEach(([rawKey, value]) => {
      const key = normalizeProfileName(rawKey);
      if (!key || !allowedConfigurations.has(key)) {
        return;
      }
      const include = value instanceof Object && !Array.isArray(value)
        ? (value as any)?.endpoints?.include ?? (value as any)?.include
        : value;
      sanitized[key] = this.sanitizeActuatorEndpoints(include);
    });

    if (!sanitized['default']?.length) {
      sanitized['default'] = [...DEFAULT_ACTUATOR_ENDPOINTS];
    }

    return sanitized;
  }

  private buildOperationResponseConfig(restConfig: any, operationKey: string): any {
    const responseType = restConfig?.requestResponse?.response?.responseType === 'DTO_DIRECT'
      ? 'DTO_DIRECT'
      : restConfig?.requestResponse?.response?.responseType === 'CUSTOM_WRAPPER'
        ? 'CUSTOM_WRAPPER'
        : 'RESPONSE_ENTITY';
    const perOperationDto = trimmed(restConfig?.requestResponse?.response?.endpointDtos?.[operationKey]);
    return {
      responseType,
      dtoName: responseType === 'CUSTOM_WRAPPER'
        ? (perOperationDto || trimmed(restConfig?.requestResponse?.response?.dtoName))
        : trimmed(restConfig?.requestResponse?.response?.dtoName),
      responseWrapper: restConfig?.requestResponse?.response?.responseWrapper === 'NONE'
        ? 'NONE'
        : restConfig?.requestResponse?.response?.responseWrapper === 'UPSERT'
          ? 'UPSERT'
          : 'STANDARD_ENVELOPE',
      enableFieldProjection: Boolean(restConfig?.requestResponse?.response?.enableFieldProjection),
      includeHateoasLinks: Boolean(restConfig?.requestResponse?.response?.includeHateoasLinks)
    };
  }

  private buildOperationDocumentationConfig(restConfig: any, docKey: string): any | null {
    const includeDefaults = restConfig?.documentation?.includeDefaultDocumentation !== false;
    const defaultDocumentation = this.getDefaultDocumentationForOperation(docKey, trimmed(restConfig?.resourceName));
    const description = trimmed(restConfig?.documentation?.endpoints?.[docKey]?.description)
      || (includeDefaults ? defaultDocumentation.description : '');
    const group = trimmed(restConfig?.documentation?.endpoints?.[docKey]?.group)
      || (includeDefaults ? defaultDocumentation.group : '');
    const descriptionTags = Array.isArray(restConfig?.documentation?.endpoints?.[docKey]?.descriptionTags)
      ? restConfig.documentation.endpoints[docKey].descriptionTags.map((item: any) => trimmed(item)).filter(Boolean)
      : [];
    const resolvedDescriptionTags = descriptionTags.length
      ? descriptionTags
      : (includeDefaults ? defaultDocumentation.descriptionTags : []);
    const deprecated = Boolean(restConfig?.documentation?.endpoints?.[docKey]?.deprecated);

    const documentation: Record<string, any> = {};
    if (description) {
      documentation['description'] = description;
    }
    if (group) {
      documentation['group'] = group;
    }
    if (resolvedDescriptionTags.length) {
      documentation['descriptionTags'] = resolvedDescriptionTags;
    }
    if (deprecated) {
      documentation['deprecated'] = true;
    }

    return Object.keys(documentation).length ? documentation : null;
  }

  private getDefaultDocumentationForOperation(
    operationKey: string,
    resourceName: string
  ): { description: string; group: string; descriptionTags: string[] } {
    const endpointLabel: Record<string, string> = {
      list: 'List',
      get: 'Get By Key',
      create: 'Create',
      update: 'Update',
      patch: 'Patch',
      delete: 'Delete',
      bulkInsert: 'Bulk Insert',
      bulkUpdate: 'Bulk Update',
      bulkDelete: 'Bulk Delete'
    };
    const target = trimmed(resourceName) || 'API';
    return {
      description: `${endpointLabel[String(operationKey)] || String(operationKey)} operation for ${target}`,
      group: `${target} Group`,
      descriptionTags: [String(operationKey)]
    };
  }

  private buildOperationRequestConfig(operationKey: string, restConfig: any): any {
    switch (operationKey) {
      case 'create':
        return {
          mode: restConfig?.requestResponse?.request?.create?.mode === 'NONE' ? 'NONE' : 'GENERATE_DTO',
          dtoName: trimmed(restConfig?.requestResponse?.request?.create?.dtoName)
        };
      case 'update':
        return {
          mode: restConfig?.requestResponse?.request?.update?.mode === 'NONE' ? 'NONE' : 'GENERATE_DTO',
          dtoName: trimmed(restConfig?.requestResponse?.request?.update?.dtoName)
        };
      case 'patch':
        return {
          mode: restConfig?.requestResponse?.request?.patch?.mode === 'JSON_PATCH' ? 'JSON_PATCH' : 'JSON_MERGE_PATCH'
        };
      case 'list':
        return {
          mode: restConfig?.requestResponse?.request?.list?.mode === 'NONE' ? 'NONE' : 'GENERATE_DTO',
          dtoName: trimmed(restConfig?.requestResponse?.request?.list?.dtoName),
          pagination: {
            enabled: Boolean(restConfig?.pagination?.enabled ?? restConfig?.pagination),
            mode: restConfig?.pagination?.mode === 'CURSOR' ? 'CURSOR' : 'OFFSET',
            sortField: trimmed(restConfig?.pagination?.sortField),
            sortDirection: restConfig?.pagination?.sortDirection === 'ASC' ? 'ASC' : 'DESC'
          },
          searchFiltering: {
            keywordSearch: Boolean(restConfig?.searchFiltering?.keywordSearch),
            jpaSpecification: Boolean(restConfig?.searchFiltering?.jpaSpecification),
            searchableFields: Array.isArray(restConfig?.searchFiltering?.searchableFields)
              ? restConfig.searchFiltering.searchableFields.map((item: any) => trimmed(item)).filter(Boolean)
              : []
          }
        };
      case 'get':
        return {
          idType: trimmed(restConfig?.requestResponse?.request?.getByIdType)
        };
      case 'delete':
        return {
          mode: restConfig?.requestResponse?.request?.delete?.mode === 'NONE' ? 'NONE' : 'GENERATE_DTO',
          dtoName: trimmed(restConfig?.requestResponse?.request?.delete?.dtoName),
          idType: trimmed(restConfig?.requestResponse?.request?.deleteByIdType)
        };
      case 'bulkInsert': {
        const createDto = trimmed(restConfig?.requestResponse?.request?.create?.dtoName);
        const derivedType = createDto ? `List<${createDto}>` : '';
        return {
          type: derivedType,
          batch: {
            batchSize: Number(restConfig?.batchOperations?.insert?.batchSize) || 1,
            enableAsyncMode: Boolean(restConfig?.batchOperations?.insert?.enableAsyncMode)
          }
        };
      }
      case 'bulkUpdate': {
        const updateDto = trimmed(restConfig?.requestResponse?.request?.update?.dtoName);
        const createDto = trimmed(restConfig?.requestResponse?.request?.create?.dtoName);
        const derivedType = updateDto ? `List<${updateDto}>` : createDto ? `List<${createDto}>` : '';
        return {
          type: derivedType,
          batch: {
            batchSize: Number(restConfig?.batchOperations?.update?.batchSize) || 1,
            updateMode: restConfig?.batchOperations?.update?.updateMode === 'PATCH' ? 'PATCH' : 'PUT',
            optimisticLockHandling: restConfig?.batchOperations?.update?.optimisticLockHandling === 'SKIP_CONFLICTS'
              ? 'SKIP_CONFLICTS'
              : 'FAIL_ON_CONFLICT',
            validationStrategy: restConfig?.batchOperations?.update?.validationStrategy === 'SKIP_DUPLICATES'
              ? 'SKIP_DUPLICATES'
              : 'VALIDATE_ALL_FIRST',
            enableAsyncMode: Boolean(restConfig?.batchOperations?.update?.enableAsyncMode),
            asyncProcessing: Boolean(restConfig?.batchOperations?.update?.asyncProcessing)
          }
        };
      }
      case 'bulkDelete': {
        const deleteDto = trimmed(restConfig?.requestResponse?.request?.delete?.dtoName);
        const deleteIdType = trimmed(restConfig?.requestResponse?.request?.deleteByIdType);
        const derivedType = deleteDto ? `List<${deleteDto}>` : deleteIdType ? `List<${deleteIdType}>` : '';
        return {
          type: derivedType,
          batch: {
            deletionStrategy: restConfig?.batchOperations?.bulkDelete?.deletionStrategy === 'HARD' ? 'HARD' : 'SOFT',
            batchSize: Number(restConfig?.batchOperations?.bulkDelete?.batchSize) || 1,
            failureStrategy: restConfig?.batchOperations?.bulkDelete?.failureStrategy === 'CONTINUE_AND_REPORT_FAILURES'
              ? 'CONTINUE_AND_REPORT_FAILURES'
              : 'STOP_ON_FIRST_ERROR',
            enableAsyncMode: Boolean(restConfig?.batchOperations?.bulkDelete?.enableAsyncMode),
            allowIncludeDeletedParam: Boolean(restConfig?.batchOperations?.bulkDelete?.allowIncludeDeletedParam)
          }
        };
      }
      default:
        return {};
    }
  }

  private mapModelField(field: any): any {
    const mapped: any = {
      name: trimmed(field?.name) || 'field',
      type: normalizeType(field?.type)
    };

    const constraints = this.mapConstraints(field?.constraints);
    if (constraints.length) {
      mapped.constraints = constraints;
    }

    const column: any = {};
    if (trimmed(field?.name)) {
      column.name = toSnakeCase(field.name);
    }
    if (typeof field?.required === 'boolean') {
      column.nullable = !field.required;
    } else if (constraints.some((constraint: any) => isNotNullConstraint(constraint))) {
      column.nullable = false;
    }
    if (field?.unique === true) {
      column.unique = true;
    }
    if (normalizeType(field?.type) === 'String' && hasNumber(field?.maxLength)) {
      column.length = Number(field.maxLength);
    }

    if (Object.keys(column).length) {
      mapped.column = column;
    }

    return mapped;
  }

  private mapDtoField(field: any): any {
    const dtoField: any = {
      name: trimmed(field?.name) || 'field',
      type: normalizeType(field?.type)
    };

    const jsonProperty = trimmed(field?.jsonProperty);
    if (jsonProperty) {
      dtoField.jsonProperty = jsonProperty;
    }

    const constraints = this.mapConstraints(field?.constraints);
    if (constraints.length) {
      dtoField.constraints = constraints;
    }

    return dtoField;
  }

  private mapClassMethods(classMethods: any): any {
    return {
      toString: Boolean(classMethods?.toString ?? true),
      hashCode: Boolean(classMethods?.hashCode ?? true),
      equals: Boolean(classMethods?.equals ?? true),
      noArgsConstructor: Boolean(classMethods?.noArgsConstructor ?? true),
      allArgsConstructor: Boolean(classMethods?.allArgsConstructor ?? true),
      builder: Boolean(classMethods?.builder ?? false)
    };
  }

  private mapRelation(relation: any): any {
    const type = trimmed(relation?.relationType) || 'ManyToOne';
    const mapped: any = {
      name: trimmed(relation?.sourceFieldName) || 'relation',
      type,
      target: trimmed(relation?.targetEntity) || 'Target'
    };

    const cascade = Array.isArray(relation?.cascade)
      ? relation.cascade.map((item: any) => trimmed(item)).filter(Boolean)
      : [];
    if (cascade.length) {
      mapped.cascade = Array.from(new Set(cascade));
    }

    const mappedBy = trimmed(relation?.mappedBy);
    if (mappedBy) {
      mapped.mappedBy = mappedBy;
    }
    if (relation?.orphanRemoval === true) {
      mapped.orphanRemoval = true;
    }
    const orderBy = trimmed(relation?.orderBy);
    if (orderBy) {
      mapped.orderBy = orderBy;
    }
    const orderColumnName = trimmed(relation?.orderColumn?.name);
    if (orderColumnName) {
      mapped.orderColumn = { name: orderColumnName };
    }

    if (type === 'ManyToOne' || type === 'OneToOne') {
      if (typeof relation?.optional === 'boolean') {
        mapped.optional = relation.optional;
      } else if (typeof relation?.required === 'boolean') {
        mapped.optional = !relation.required;
      }
      const joinColumn = this.mapJoinColumn(relation?.joinColumn);
      if (joinColumn) {
        mapped.joinColumn = joinColumn;
      }
    }

    if (type === 'ManyToMany') {
      const joinTable = this.mapJoinTable(relation?.joinTable);
      if (joinTable) {
        mapped.joinTable = joinTable;
      }
    }

    return mapped;
  }

  private mapJoinColumn(joinColumn: any): any | null {
    if (!joinColumn || typeof joinColumn !== 'object') {
      return null;
    }
    const mapped: any = {};
    const name = trimmed(joinColumn?.name);
    const referenced = trimmed(joinColumn?.referencedColumnName);
    if (name) {
      mapped.name = name;
    }
    if (referenced) {
      mapped.referencedColumnName = referenced;
    }
    if (typeof joinColumn?.nullable === 'boolean') {
      mapped.nullable = joinColumn.nullable;
    }
    if (joinColumn?.index === true) {
      mapped.index = true;
    }
    const onDelete = trimmed(joinColumn?.onDelete);
    if (onDelete) {
      mapped.onDelete = onDelete;
    }
    return Object.keys(mapped).length ? mapped : null;
  }

  private mapJoinTable(joinTable: any): any | null {
    if (!joinTable || typeof joinTable !== 'object') {
      return null;
    }

    const mapped: any = {};
    const name = trimmed(joinTable?.name);
    if (name) {
      mapped.name = name;
    }

    const joinColumns = this.mapJoinColumns(joinTable?.joinColumns);
    if (joinColumns.length) {
      mapped.joinColumns = joinColumns;
    }

    const inverseJoinColumns = this.mapJoinColumns(joinTable?.inverseJoinColumns);
    if (inverseJoinColumns.length) {
      mapped.inverseJoinColumns = inverseJoinColumns;
    }

    if (joinTable?.uniquePair === true) {
      mapped.uniquePair = true;
    }
    const onDelete = trimmed(joinTable?.onDelete);
    if (onDelete) {
      mapped.onDelete = onDelete;
    }

    return Object.keys(mapped).length ? mapped : null;
  }

  private mapJoinColumns(columns: any): any[] {
    const items = Array.isArray(columns) ? columns : [];
    return items.map((column) => this.mapJoinColumn(column)).filter(Boolean);
  }

  private mapConstraints(constraints: any): any[] {
    const items = Array.isArray(constraints) ? constraints : [];
    return items.map((constraint: any) => this.mapConstraint(constraint)).filter(Boolean);
  }

  private mapConstraint(constraint: any): any | null {
    const name = trimmed(constraint?.name);
    if (!name) {
      return null;
    }

    const value = trimmed(constraint?.value);
    const value2 = trimmed(constraint?.value2);
    const params: any = {};

    if (name === 'Size') {
      if (value) {
        params.min = toNumberIfPossible(value);
      }
      if (value2) {
        params.max = toNumberIfPossible(value2);
      }
    } else if (name === 'Min' || name === 'Max') {
      if (value) {
        params.value = toNumberIfPossible(value);
      }
    } else if (name === 'DecimalMin' || name === 'DecimalMax') {
      if (value) {
        params.value = value;
      }
      if (value2) {
        params.inclusive = toBooleanIfPossible(value2);
      }
    } else if (name === 'Digits') {
      if (value) {
        params.integer = toNumberIfPossible(value);
      }
      if (value2) {
        params.fraction = toNumberIfPossible(value2);
      }
    } else if (name === 'Pattern') {
      if (value) {
        params.regex = value;
      }
    } else {
      if (value) {
        params.value = toNumberIfPossible(value);
      }
      if (value2) {
        params.value2 = toNumberIfPossible(value2);
      }
    }

    if (Object.keys(params).length === 0) {
      return name;
    }

    return { [name]: params };
  }

  private mapId(primaryKeyField: any): any {
    if (!primaryKeyField) {
      return {
        field: 'id',
        type: 'Long',
        generation: {
          strategy: 'IDENTITY'
        }
      };
    }

    const type = normalizeType(primaryKeyField?.type);
    const generation = type === 'UUID'
      ? { strategy: 'UUID', generatorName: 'uuid', hibernateUuidStrategy: 'uuid2' }
      : { strategy: 'IDENTITY' };

    return {
      field: trimmed(primaryKeyField?.name) || 'id',
      type,
      generation
    };
  }

  parseControllersConfig(rawConfig: RestEndpointConfig | null | undefined): RestEndpointConfig {
    const fallback = { ...DEFAULT_CONTROLLERS_CONFIG };
    if (!rawConfig || typeof rawConfig !== 'object') {
      return fallback;
    }
    const cloned = JSON.parse(JSON.stringify(rawConfig)) as RestEndpointConfig;
    return {
      ...fallback,
      ...cloned,
      mapToEntity: Boolean((cloned as any).mapToEntity ?? fallback.mapToEntity),
      mappedEntityName: trimmed((cloned as any).mappedEntityName),
      methods: { ...fallback.methods, ...(cloned as any).methods },
      apiVersioning: { ...fallback.apiVersioning, ...(cloned as any).apiVersioning },
      deletion: { ...fallback.deletion, ...(cloned as any).deletion },
      hateoas: { ...fallback.hateoas, ...(cloned as any).hateoas },
      pagination: { ...fallback.pagination, ...(cloned as any).pagination },
      searchFiltering: { ...fallback.searchFiltering, ...(cloned as any).searchFiltering },
      batchOperations: {
        insert: { ...fallback.batchOperations.insert, ...(cloned as any).batchOperations?.insert },
        update: { ...fallback.batchOperations.update, ...(cloned as any).batchOperations?.update },
        bulkDelete: { ...fallback.batchOperations.bulkDelete, ...(cloned as any).batchOperations?.bulkDelete }
      },
      requestResponse: {
        request: {
          ...fallback.requestResponse.request,
          ...(cloned as any).requestResponse?.request,
          list: { ...fallback.requestResponse.request.list, ...(cloned as any).requestResponse?.request?.list },
          create: { ...fallback.requestResponse.request.create, ...(cloned as any).requestResponse?.request?.create },
          delete: { ...fallback.requestResponse.request.delete, ...(cloned as any).requestResponse?.request?.delete },
          update: { ...fallback.requestResponse.request.update, ...(cloned as any).requestResponse?.request?.update },
          patch: { ...fallback.requestResponse.request.patch, ...(cloned as any).requestResponse?.request?.patch }
        },
        response: {
          ...fallback.requestResponse.response,
          ...(cloned as any).requestResponse?.response,
          endpointDtos: {
            ...fallback.requestResponse.response.endpointDtos,
            ...(cloned as any).requestResponse?.response?.endpointDtos
          }
        }
      },
      documentation: {
        includeDefaultDocumentation: (cloned as any).documentation?.includeDefaultDocumentation !== false,
        endpoints: {
          ...fallback.documentation.endpoints,
          ...(cloned as any).documentation?.endpoints
        }
      }
    };
  }
}
